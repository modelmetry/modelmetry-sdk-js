/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/checks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Check payload */
        post: operations["check-payload"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/evaluations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Evaluate */
        post: operations["evaluate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/signals/ingest/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Ingest signals v1 */
        post: operations["ingest-signals-v1"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        Assessment: {
            /**
             * @default pass
             * @enum {string}
             */
            Action: "pass" | "fail" | "skip";
            Expression: string;
            ID: string;
            Message: string;
        };
        AssistantMessage: {
            Contents: (components["schemas"]["TextPart"] | components["schemas"]["DataPart"])[];
            Name?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            Role: "assistant";
            ToolCalls?: components["schemas"]["ToolCall"][] | null;
        };
        AzurePromptShieldsV1Config: {
            /**
             * Format: uri
             * @description The endpoint of the Azure Prompt Shields API.
             */
            Endpoint: string;
        };
        CheckPayloadRequestBody: {
            /**
             * Format: uri
             * @description A URL to the JSON Schema for this object.
             */
            readonly $schema?: string;
            GuardrailID: string;
            Payload: components["schemas"]["Payload"];
            TenantID?: string;
        };
        CompletionFamilyData: {
            Cost?: components["schemas"]["Cost"];
            Documents?: components["schemas"]["Document"][];
            Messages?: (components["schemas"]["SystemMessage"] | components["schemas"]["UserMessage"] | components["schemas"]["AssistantMessage"] | components["schemas"]["ToolMessage"])[];
            Options?: components["schemas"]["Options"];
            Usage?: components["schemas"]["Usage"];
        };
        CompletionPayload: {
            Messages: (components["schemas"]["SystemMessage"] | components["schemas"]["UserMessage"] | components["schemas"]["AssistantMessage"] | components["schemas"]["ToolMessage"])[];
            Options: {
                [key: string]: unknown;
            };
        };
        Cost: {
            Input?: components["schemas"]["Money"];
            Output?: components["schemas"]["Money"];
            Total?: components["schemas"]["Money"];
        };
        CreateEventParams: {
            /** Format: date-time */
            At?: string | null;
            EntryID?: string | null;
            Metadata?: {
                [key: string]: unknown;
            };
            Name: string;
            SpanID?: string | null;
            TraceID?: string | null;
            XID: string;
        };
        CreateFindingParams: {
            /** Format: date-time */
            At?: string | null;
            Comment?: string | null;
            Description?: string | null;
            EntryID?: string | null;
            Metadata?: {
                [key: string]: unknown;
            };
            Name: string;
            /**
             * @default annotation
             * @enum {string|null}
             */
            Source: "annotation" | "evaluator" | "sdk";
            SpanID?: string | null;
            TraceID?: string | null;
            Value: number | boolean | string;
            XID: string;
        };
        CreateSessionParams: {
            Metadata?: {
                [key: string]: unknown;
            };
            Name?: string | null;
            XID: string;
        };
        CreateSpanParams: {
            /** Format: date-time */
            End: string | null;
            Family?: string | null;
            FamilyData?: unknown;
            Message?: string | null;
            Metadata?: {
                [key: string]: unknown;
            };
            Name: string;
            ParentID?: string | null;
            Severity?: string | null;
            /** Format: date-time */
            Start: string;
            TraceID: string;
            XID: string;
        };
        CreateTraceParams: {
            /** Format: date-time */
            End?: string | null;
            Metadata?: {
                [key: string]: unknown;
            };
            Name?: string | null;
            SessionID?: string | null;
            /** Format: date-time */
            Start: string;
            XID: string;
        };
        DataPart: {
            Data: string;
            /** @enum {string} */
            Detail?: "auto" | "low" | "high";
            MimeType: string;
        };
        Document: {
            Content?: unknown;
            ContentType: string;
            Identifier: string;
            Metadata?: {
                [key: string]: unknown;
            };
            Title: string;
        };
        EmbeddingsFamilyData: {
            Inputs: string[] | null;
            Options: components["schemas"]["Options"];
        };
        Entry: {
            /**
             * Format: uri
             * @description A URL to the JSON Schema for this object.
             */
            readonly $schema?: string;
            CheckID: string | null;
            Config: {
                [key: string]: unknown;
            };
            /** Format: date-time */
            CreatedAt: string;
            CreatedBy: string;
            /** Format: int64 */
            DurationMs: number;
            EvaluatorID: string;
            Findings: components["schemas"]["Finding"][] | null;
            /** Format: date-time */
            FinishedAt: string | null;
            Grading: components["schemas"]["GradingConfiguration"];
            ID: string;
            InstanceID: string | null;
            Message: string;
            Metadata: {
                [key: string]: unknown;
            };
            /**
             * @description The status of the entry.
             * @default na
             * @enum {string}
             */
            Outcome: "na" | "pending" | "pass" | "fail" | "error" | "skip";
            Payload: components["schemas"]["Payload"];
            Skip: string;
            SpanID: string | null;
            /** Format: date-time */
            StartedAt: string;
            TenantID: string;
            TraceID: string | null;
            /** Format: date-time */
            UpdatedAt: string;
            UpdatedBy: string;
        };
        ErrorDetail: {
            /** @description Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id' */
            location?: string;
            /** @description Error message text */
            message?: string;
            /** @description The value at the given location */
            value?: unknown;
        };
        ErrorModel: {
            /**
             * Format: uri
             * @description A URL to the JSON Schema for this object.
             */
            readonly $schema?: string;
            /** @description A human-readable explanation specific to this occurrence of the problem. */
            detail?: string;
            /** @description Optional list of individual error details */
            errors?: components["schemas"]["ErrorDetail"][] | null;
            /**
             * Format: uri
             * @description A URI reference that identifies the specific occurrence of the problem.
             */
            instance?: string;
            /**
             * Format: int64
             * @description HTTP status code
             */
            status?: number;
            /** @description A short, human-readable summary of the problem type. This value should not change between occurrences of the error. */
            title?: string;
            /**
             * Format: uri
             * @description A URI reference to human-readable documentation for the error.
             * @default about:blank
             */
            type: string;
        };
        EvaluateRequestBody: {
            /**
             * Format: uri
             * @description A URL to the JSON Schema for this object.
             */
            readonly $schema?: string;
            ByConfig?: components["schemas"]["EvaluateRequestByConfig"];
            ByEntry?: components["schemas"]["EvaluateRequestByEntry"];
            ByInstance?: components["schemas"]["EvaluateRequestByInstance"];
            Persist?: boolean | null;
            TenantID: string;
        };
        EvaluateRequestByConfig: {
            Config: {
                [key: string]: unknown;
            };
            EvaluatorID: string;
            Grading?: components["schemas"]["GradingConfiguration"];
            Payload: components["schemas"]["Payload"];
            Secrets?: string[] | null;
        };
        EvaluateRequestByEntry: {
            EntryID: string;
        };
        EvaluateRequestByInstance: {
            InstanceID: string;
            Payload: components["schemas"]["Payload"];
        };
        Event: {
            /** Format: date-time */
            CreatedAt: string;
            EntryID: string | null;
            ID: string;
            Metadata: {
                [key: string]: unknown;
            };
            Name: string;
            SpanID: string | null;
            TenantID: string;
            TraceID: string | null;
            /** Format: date-time */
            UpdatedAt: string;
            XID: string;
        };
        Finding: {
            CheckID?: string;
            Comment: string;
            /** Format: date-time */
            CreatedAt: string;
            EntryID?: string;
            EvaluatorID: string | null;
            ID: string;
            Metadata: {
                [key: string]: unknown;
            };
            Name: string;
            /**
             * @default annotation
             * @enum {string}
             */
            Source: "annotation" | "evaluator" | "sdk";
            SpanID?: string;
            TenantID: string;
            TraceID?: string;
            Unit: string;
            /** Format: date-time */
            UpdatedAt: string;
            Value: number | boolean | string;
            XID: string;
        };
        FullTrace: {
            /** Format: date-time */
            CreatedAt: string;
            /** Format: date-time */
            End: string;
            Events: components["schemas"]["Event"][] | null;
            Findings: components["schemas"]["Finding"][] | null;
            ID: string;
            Metadata: {
                [key: string]: unknown;
            };
            Name: string;
            SessionID?: string | null;
            Spans: components["schemas"]["Span"][] | null;
            /** Format: date-time */
            Start: string;
            TenantID: string;
            /** Format: date-time */
            UpdatedAt: string;
            XID: string;
        };
        Function: {
            Arguments: unknown;
            Name: string;
        };
        GoogleDLPPIIDetectorV1Config: {
            /** @description Info types to detect as per Google Cloud DLP's documentation */
            InfoTypes: string[] | null;
            /**
             * @description Threshold for detection
             * @default LIKELY
             * @enum {string}
             */
            MinimumLikelihood: "VERY_LIKELY" | "LIKELY" | "POSSIBLE" | "UNLIKELY" | "VERY_UNLIKELY";
        };
        GoogleTextModerationV1Config: {
            /**
             * @description The attributes to check for. An empty list will check for all attributes.
             * @default []
             */
            Attributes: ("TOXICITY" | "DEROGATORY" | "VIOLENCE" | "SEX" | "INSULT" | "PROFANITY" | "THREAT" | "WEAPONS" | "PUBLIC_SAFETY" | "HEALTH" | "RELIGION" | "ILLICIT_DRUGS" | "WAR" | "FINANCIAL" | "POLITICAL" | "LEGAL")[];
        };
        GradingConfiguration: {
            Assessments: components["schemas"]["Assessment"][];
        };
        GuardrailCheck: {
            /**
             * Format: uri
             * @description A URL to the JSON Schema for this object.
             */
            readonly $schema?: string;
            /** Format: date-time */
            CreatedAt: string;
            CreatedBy: string;
            /** Format: int64 */
            DurationMs: number;
            GuardrailID: string;
            ID: string;
            Metadata: {
                [key: string]: unknown;
            };
            /**
             * @description The status of the entry.
             * @default na
             * @enum {string}
             */
            Outcome: "pass" | "fail" | "error";
            Payload: components["schemas"]["Payload"];
            SummarisedEntries: components["schemas"]["SummarisedEntry"][] | null;
            TenantID: string;
            /** Format: date-time */
            UpdatedAt: string;
            UpdatedBy: string;
        };
        IngestSignalsV1RequestBody: {
            /**
             * Format: uri
             * @description A URL to the JSON Schema for this object.
             */
            readonly $schema?: string;
            Events?: components["schemas"]["CreateEventParams"][] | null;
            Findings?: components["schemas"]["CreateFindingParams"][] | null;
            Sessions?: components["schemas"]["CreateSessionParams"][] | null;
            Spans?: components["schemas"]["CreateSpanParams"][] | null;
            Traces?: components["schemas"]["CreateTraceParams"][] | null;
        };
        IngestSignalsV1ResponseBody: {
            /**
             * Format: uri
             * @description A URL to the JSON Schema for this object.
             */
            readonly $schema?: string;
        };
        ModelmetryBooleanLLMAsJudgeV1Config: {
            /** @description The name of the finding to use for this evaluator's boolean output (e.g., is_threatening, is_about_hotels). */
            FindingName: string;
            /** @description You are an LLM evaluator. We need the guarantee that the output answers what is being asked on the input, please evaluate as False if it doesn't. */
            Instructions: string;
            /**
             * Format: int64
             * @description The limit on the number of tokens the entire prompt can be.
             * @default 8192
             */
            MaxTokens: number;
            /**
             * @description The model to use.
             * @default openai/gpt-4o-mini
             * @enum {string}
             */
            Model: "openai/gpt-4o-mini" | "openai/gpt-4o" | "openai/gpt-3.5-turbo" | "groq/llama3-8b-8192" | "groq/llama3-70b-8192" | "groq/mixtral-8x7b-32768" | "groq/gemma-7b-it" | "google/gemini-1.5-flash" | "google/gemini-1.5-pro";
        };
        ModelmetryCompetitorBlocklistV1Config: {
            /**
             * @description Whether to consider the word's case when matching strings
             * @default case_sensitive
             * @enum {string}
             */
            CaseSensitivity: "case_sensitive" | "case_insensitive";
            /** @description List of competitors to search for */
            Competitors: string[] | null;
            /**
             * @description Where to search for competitor mentions
             * @default *
             * @enum {string}
             */
            LookIn: "user" | "assistant" | "*";
        };
        ModelmetryEmbeddingsSimilarityV1Config: {
            /**
             * @description The method to use for extracting text strings.
             * @enum {string}
             */
            ExtractionMethod: "last-user-vs-assistant" | "reference-vs-all-messages" | "reference-vs-last-assistant" | "reference-vs-last-user";
            /**
             * @description The model to use for encoding text to embeddings (only OpenAI models at this stage).
             * @enum {string}
             */
            Model: "openai/text-embedding-3-small" | "openai/text-embedding-3-large";
            /** @description The reference text to compare against. Be as detailed or as general as you like. */
            ReferenceText: string;
            /**
             * @description The strategy to use for computing similarity.
             * @enum {string}
             */
            Strategy: "cosine" | "euclidean-distance" | "dot-product";
        };
        ModelmetryEmotionAnalysisV1Config: Record<string, never>;
        ModelmetryHTTPRequestV1Config: {
            /** @description The JSON path to the findings in the response body. */
            FindingsJSONPath?: string | null;
            /** @description A map of headers to include in the request. */
            Headers: {
                [key: string]: string;
            };
            /** @description The JSON path to the message in the response body. */
            MessageJSONPath?: string | null;
            /**
             * @description The HTTP method to use for the request.
             * @default POST
             * @enum {string}
             */
            Method: "POST";
            /** @description The JSON path to the outcome in the response body. */
            OutcomeJSONPath?: string | null;
            /**
             * Format: uri
             * @description The URL to send the HTTP request to.
             */
            URL: string;
        };
        ModelmetryJSONValidatorV1Config: {
            /** @description The expected JSON schema to validate against */
            ExpectedJSONSchema?: string;
        };
        ModelmetryLanguageDetectorV1Config: {
            /**
             * Format: double
             * @description Minimum confidence threshold for the language detection. If the confidence is lower than this, the evaluation will be skipped.
             * @default 0.2
             */
            ConfidenceThreshold: number;
            /**
             * Format: int64
             * @description Minimum number of words to check, as the language detection can be unreliable for very short texts. Texts shorter than the minimum will be skipped.
             * @default 2
             */
            WordCountThreshold: number;
        };
        ModelmetryScoreLLMAsJudgeV1Config: {
            /** @description The name of the finding to use for the result (e.g., threatening_level, about_hotel_score). */
            FindingName: string;
            /** @description You are an LLM evaluator. Please score from 0.0 to 1.0 how likely the user is to be satisfied with this answer, from 0.0 being not satisfied at all to 1.0 being completely satisfied. */
            Instructions: string;
            /**
             * Format: int64
             * @description The limit on the number of tokens the entire prompt can be.
             * @default 8192
             */
            MaxTokens: number;
            /**
             * @description The model to use.
             * @default openai/gpt-4o-mini
             * @enum {string}
             */
            Model: "openai/gpt-4o-mini" | "openai/gpt-4o" | "openai/gpt-3.5-turbo" | "groq/llama3-8b-8192" | "groq/llama3-70b-8192" | "groq/mixtral-8x7b-32768" | "groq/gemma-7b-it" | "google/gemini-1.5-flash" | "google/gemini-1.5-pro";
        };
        ModelmetrySecretDetectorV1Config: {
            /** @description Custom regex patterns to detect secrets */
            CustomPatterns?: {
                [key: string]: string;
            };
        };
        ModelmetrySentimentAnalysisV1Config: {
            /**
             * @description The model to use.
             * @default openai/gpt-4o-mini
             * @enum {string}
             */
            Model: "openai/gpt-4o-mini" | "openai/gpt-4o" | "openai/gpt-3.5-turbo" | "groq/llama3-8b-8192" | "groq/llama3-70b-8192" | "groq/mixtral-8x7b-32768" | "groq/gemma-7b-it" | "google/gemini-1.5-flash" | "google/gemini-1.5-pro";
            /** @enum {string} */
            Scope: "interaction.last" | "user.last" | "assistant.last" | "last";
        };
        ModelmetryTextReadabilityV1Config: {
            /**
             * @default last
             * @enum {string}
             */
            Scope: "interaction.last" | "user.last" | "assistant.last" | "last";
        };
        ModelmetryToolsCalledV1Config: {
            Expectations?: unknown;
            /** @description The expected JSON schema to validate against */
            Expections: components["schemas"]["ModelmetryToolsCalledV1Expectation"][];
        };
        ModelmetryToolsCalledV1Expectation: {
            /** @description The expression to check the tool call's arguements against */
            Expression: string;
            /** @description The name of the tool call */
            Name: string;
        };
        Money: {
            Amount: number;
            Currency: string;
        };
        Options: {
            APIKey?: string;
            APIVersion?: string;
            BaseURL?: string;
            DeploymentID?: string;
            /** Format: double */
            FrequencyPenalty?: number;
            FunctionCall?: string;
            Functions?: string[] | null;
            LogitBias?: {
                [key: string]: unknown;
            };
            Logprobs?: boolean;
            /** Format: int64 */
            MaxTokens?: number;
            Model?: string;
            ModelList?: string[] | null;
            /** Format: int64 */
            N?: number;
            /** Format: double */
            PresencePenalty?: number;
            Provider?: string;
            ResponseFormat?: {
                [key: string]: unknown;
            };
            /** Format: int64 */
            Seed?: number;
            Stop?: {
                [key: string]: unknown;
            };
            Stream?: boolean;
            /** Format: double */
            Temperature?: number;
            /** Format: double */
            Timeout?: number;
            ToolChoice?: string;
            Tools?: components["schemas"]["Tool"][] | null;
            /** Format: int64 */
            TopLogprobs?: number;
            /** Format: double */
            TopP?: number;
            User?: string;
        };
        OtherFamilyData: Record<string, never>;
        Payload: {
            Completion?: components["schemas"]["CompletionPayload"];
        };
        RetrievalFamilyData: {
            Documents: components["schemas"]["Document"][] | null;
            Queries: components["schemas"]["RetrievalQuery"][] | null;
        };
        RetrievalQuery: {
            Embeddings?: number[] | null;
            TextRepresentation: string;
        };
        SimplifiedFinding: {
            Comment: string;
            /** Format: date-time */
            CreatedAt: string;
            EvaluatorID: string | null;
            Metadata: {
                [key: string]: unknown;
            };
            Name: string;
            /**
             * @default annotation
             * @enum {string}
             */
            Source: "annotation" | "evaluator" | "sdk";
            Value: number | boolean | string;
        };
        Span: {
            Completion?: components["schemas"]["CompletionFamilyData"];
            /** Format: date-time */
            CreatedAt: string;
            Embeddings?: components["schemas"]["EmbeddingsFamilyData"];
            /** Format: date-time */
            End: string;
            Events: components["schemas"]["Event"][] | null;
            Family: string;
            Findings: components["schemas"]["Finding"][] | null;
            ID: string;
            Message: string;
            Metadata: {
                [key: string]: unknown;
            };
            Name: string;
            Other?: components["schemas"]["OtherFamilyData"];
            ParentID: string | null;
            Retrieval?: components["schemas"]["RetrievalFamilyData"];
            Severity: string;
            /** Format: date-time */
            Start: string;
            TenantID: string;
            TraceID: string;
            /** Format: date-time */
            UpdatedAt: string;
            XID: string;
        };
        SummarisedEntry: {
            CheckID: string | null;
            /** Format: int64 */
            DurationMs: number;
            EvaluatorID: string;
            Findings: components["schemas"]["SimplifiedFinding"][] | null;
            ID: string;
            InstanceID: string | null;
            Message: string;
            /**
             * @description The status of the entry.
             * @default na
             * @enum {string}
             */
            Outcome: "na" | "pending" | "pass" | "fail" | "error" | "skip";
            Skip: string;
            SpanID: string | null;
            TenantID: string;
            TraceID: string | null;
        };
        SystemMessage: {
            Contents: (components["schemas"]["TextPart"] | components["schemas"]["DataPart"])[];
            Name?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            Role: "system";
        };
        TextPart: {
            Text: string;
        };
        Tool: {
            Description: string;
            Name: string;
            Parameters: unknown;
        };
        ToolCall: {
            Function: components["schemas"]["Function"];
            ID: string;
            /** @enum {string} */
            Type: "function";
        };
        ToolMessage: {
            Contents: (components["schemas"]["TextPart"] | components["schemas"]["DataPart"])[];
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            Role: "tool";
            ToolCallID: string;
        };
        Trace: {
            /** Format: date-time */
            CreatedAt: string;
            /** Format: date-time */
            End: string;
            ID: string;
            Metadata: {
                [key: string]: unknown;
            };
            Name: string;
            SessionID?: string | null;
            /** Format: date-time */
            Start: string;
            TenantID: string;
            /** Format: date-time */
            UpdatedAt: string;
            XID: string;
        };
        Usage: {
            Input?: components["schemas"]["UsageValue"];
            Output?: components["schemas"]["UsageValue"];
            Total?: components["schemas"]["UsageValue"];
        };
        UsageValue: {
            /** Format: double */
            Amount: number;
            /** @default tokens */
            Unit: string;
        };
        UserMessage: {
            Contents: (components["schemas"]["TextPart"] | components["schemas"]["DataPart"])[];
            Name?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            Role: "user";
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    "check-payload": {
        parameters: {
            query?: {
                dryrun?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CheckPayloadRequestBody"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GuardrailCheck"];
                };
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ErrorModel"];
                };
            };
        };
    };
    evaluate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EvaluateRequestBody"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Entry"];
                };
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ErrorModel"];
                };
            };
        };
    };
    "ingest-signals-v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IngestSignalsV1RequestBody"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IngestSignalsV1ResponseBody"];
                };
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ErrorModel"];
                };
            };
        };
    };
}
